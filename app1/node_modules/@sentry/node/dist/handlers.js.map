{"version":3,"file":"handlers.js","sourceRoot":"","sources":["../src/handlers.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,qCAAsC;AACtC,mCAAuD;AACvD,uCAAsD;AACtD,6CAA6C;AAC7C,+CAAiD;AACjD,+BAAiC;AACjC,+BAAiC;AAEjC,uBAAyB;AACzB,yBAA2B;AAE3B,6BAAsC;AAEtC,IAAM,wBAAwB,GAAG,IAAI,CAAC;AAEtC,YAAY;AACZ,SAAS,kBAAkB,CAAC,GAA2B;IACrD,WAAW;IACX,+BAA+B;IAC/B,oBAAoB;IACpB,IAAM,OAAO,GAAG,CAAC,GAAG,CAAC,OAAO,IAAI,GAAG,CAAC,MAAM,IAAI,EAAE,CAG/C,CAAC;IACF,UAAU;IACV,mCAAmC;IACnC,IAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;IAC1B,QAAQ;IACR,qDAAqD;IACrD,kBAAkB;IAClB,2BAA2B;IAC3B,IAAM,IAAI,GAAG,GAAG,CAAC,QAAQ,IAAI,GAAG,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI,IAAI,WAAW,CAAC;IACrE,YAAY;IACZ,gBAAgB;IAChB,+BAA+B;IAC/B,IAAM,QAAQ,GACZ,GAAG,CAAC,QAAQ,KAAK,OAAO,IAAI,GAAG,CAAC,MAAM,IAAK,CAAC,GAAG,CAAC,MAAM,IAAI,EAAE,CAA6B,CAAC,SAAS;QACjG,CAAC,CAAC,OAAO;QACT,CAAC,CAAC,MAAM,CAAC;IACb,yCAAyC;IACzC,mCAAmC;IACnC,iBAAiB;IACjB,IAAM,WAAW,GAAG,CAAC,GAAG,CAAC,WAAW,IAAI,GAAG,CAAC,GAAG,CAAW,CAAC;IAC3D,eAAe;IACf,IAAM,WAAW,GAAM,QAAQ,WAAM,IAAI,GAAG,WAAa,CAAC;IAC1D,gBAAgB;IAChB,wBAAwB;IACxB,4BAA4B;IAC5B,IAAM,KAAK,GAAG,GAAG,CAAC,KAAK,IAAI,GAAG,CAAC,KAAK,CAAC,WAAW,IAAI,EAAE,EAAE,IAAI,CAAC,CAAC,KAAK,CAAC;IACpE,WAAW;IACX,2CAA2C;IAC3C,IAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC;IACnD,aAAa;IACb,iCAAiC;IACjC,IAAI,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;IACpB,IAAI,MAAM,KAAK,KAAK,IAAI,MAAM,KAAK,MAAM,EAAE;QACzC,IAAI,OAAO,IAAI,KAAK,WAAW,EAAE;YAC/B,IAAI,GAAG,eAAe,CAAC;SACxB;KACF;IACD,IAAI,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,iBAAiB,EAAE;QACpF,yCAAyC;QACzC,IAAI,GAAG,kBAAS,CAAC,IAAI,CAAC,CAAC;KACxB;IAED,oBAAoB;IACpB,IAAM,OAAO,GAET;QACF,OAAO,SAAA;QACP,IAAI,MAAA;QACJ,OAAO,SAAA;QACP,MAAM,QAAA;QACN,YAAY,EAAE,KAAK;QACnB,GAAG,EAAE,WAAW;KACjB,CAAC;IAEF,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,YAAY;AACZ,SAAS,eAAe,CAAC,GAA2B;IAClD,IAAM,IAAI,GAA8B,EAAE,CAAC;IAE3C,CAAC,IAAI,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG;QACrC,IAAI,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;YACzC,IAAI,CAAC,GAAG,CAAC,GAAI,GAAG,CAAC,IAAkC,CAAC,GAAG,CAAC,CAAC;SAC1D;IACH,CAAC,CAAC,CAAC;IAEH,aAAa;IACb,uCAAuC;IACvC,yBAAyB;IACzB,IAAM,EAAE,GACN,GAAG,CAAC,EAAE;QACN,CAAC,GAAG,CAAC,UAAU;YACZ,GAAG,CAAC,UAEH,CAAC,aAAa,CAAC,CAAC;IAEtB,IAAI,EAAE,EAAE;QACN,IAAI,CAAC,UAAU,GAAG,EAAY,CAAC;KAChC;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED,YAAY;AACZ,SAAS,YAAY,CACnB,KAAkB,EAClB,GAEC;IAED,IAAM,aAAa,gBACd,KAAK,IACR,KAAK,eACA,KAAK,CAAC,KAAK,IACd,IAAI,EAAE,MAAM,CAAC,OAAO,CAAC,OAAO,KAE9B,OAAO,eACF,KAAK,CAAC,OAAO,EACb,kBAAkB,CAAC,GAAG,CAAC,GAE5B,WAAW,EAAE,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,WAAW,IAAI,EAAE,CAAC,QAAQ,EAAE,GAC7D,CAAC;IAEF,IAAI,GAAG,CAAC,IAAI,EAAE;QACZ,aAAa,CAAC,IAAI,gBACb,KAAK,CAAC,IAAI,EACV,eAAe,CAAC,GAAG,CAAC,CACxB,CAAC;KACH;IAED,OAAO,aAAa,CAAC;AACvB,CAAC;AAED,YAAY;AACZ,SAAgB,cAAc;IAC5B,OAAO,SAAS,uBAAuB,CACrC,GAAyB,EACzB,IAAyB,EACzB,IAAgB;QAHX,iBAaN;QARC,IAAM,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC;QAC9B,IAAM,GAAG,GAAG,uBAAiB,CAAC,GAAG,CAAC,CAAC;QACnC,GAAG,CAAC,UAAU,CAAC,mBAAa,EAAE,CAAC,SAAS,EAAE,CAAC,CAAC;QAC5C,GAAG,CAAC,cAAc,CAAC,UAAC,KAAY;YAC9B,KAAK,CAAC,iBAAiB,CAAC,UAAO,KAAkB;gBAAK,sBAAA,YAAY,CAAC,KAAK,EAAE,GAAG,CAAC,EAAA;qBAAA,CAAC,CAAC;QAClF,CAAC,CAAC,CAAC;QACH,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACxB,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAClB,CAAC,CAAC;AACJ,CAAC;AAfD,wCAeC;AAYD,YAAY;AACZ,SAAS,yBAAyB,CAAC,KAAsB;IACvD,IAAM,UAAU,GAAG,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,UAAU,IAAI,KAAK,CAAC,WAAW,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;IAEtH,OAAO,UAAU,CAAC,CAAC,CAAC,QAAQ,CAAC,UAAoB,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;AAC/D,CAAC;AAED,YAAY;AACZ,SAAgB,YAAY;IAM1B,OAAO,SAAS,qBAAqB,CACnC,KAAsB,EACtB,GAAyB,EACzB,IAAyB,EACzB,IAAsC;QAEtC,IAAM,MAAM,GAAG,yBAAyB,CAAC,KAAK,CAAC,CAAC;QAChD,IAAI,MAAM,GAAG,GAAG,EAAE;YAChB,IAAI,CAAC,KAAK,CAAC,CAAC;YACZ,OAAO;SACR;QACD,uBAAiB,CAAC,GAAG,CAAC,CAAC,gBAAgB,CAAC,KAAK,EAAE,EAAE,iBAAiB,EAAE,KAAK,EAAE,CAAC,CAAC;QAC7E,IAAI,CAAC,KAAK,CAAC,CAAC;IACd,CAAC,CAAC;AACJ,CAAC;AApBD,oCAoBC;AAED,YAAY;AACZ,SAAgB,mBAAmB,CAAC,KAAY;IAC9C,OAAO,CAAC,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IAC1D,IAAM,OAAO,GAAI,mBAAa,EAAE,CAAC,SAAS,EAAiB,CAAC,UAAU,EAAE,CAAC;IACzE,IAAM,OAAO,GACX,CAAC,OAAO,IAAI,OAAO,CAAC,eAAe,IAAI,OAAO,CAAC,eAAe,GAAG,CAAC,IAAI,OAAO,CAAC,eAAe,CAAC;QAC9F,wBAAwB,CAAC;IAC3B,cAAM,CACH,mBAAa,EAAE,CAAC,SAAS,EAAiB,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,UAAC,MAAe;QAC9E,IAAI,CAAC,MAAM,EAAE;YACX,aAAM,CAAC,IAAI,CAAC,4EAA4E,CAAC,CAAC;SAC3F;QACD,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC,CACH,CAAC;AACJ,CAAC;AAdD,kDAcC;AAED,YAAY;AACZ,SAAgB,gBAAgB,CAC9B,YAAoF;IADtF,iBA+DC;IA9DC,6BAAA,EAAA,kCAAoF;IAEpF,IAAM,OAAO,GAAG,IAAI,CAAC;IACrB,IAAI,gBAAgB,GAAY,KAAK,CAAC;IACtC,IAAI,iBAAiB,GAAY,KAAK,CAAC;IACvC,IAAI,gBAAgB,GAAY,KAAK,CAAC;IACtC,IAAI,UAAiB,CAAC;IAEtB,OAAO,UAAC,KAAY;QAClB,IAAI,CAAC,gBAAgB,EAAE;YACrB,6EAA6E;YAC7E,0EAA0E;YAC1E,6FAA6F;YAC7F,UAAU,GAAG,KAAK,CAAC;YACnB,gBAAgB,GAAG,IAAI,CAAC;YAExB,mBAAa,EAAE,CAAC,SAAS,CAAC;;;oBACxB,mBAAa,EAAE,CAAC,cAAc,CAAC,UAAC,KAAY;wBAC1C,KAAK,CAAC,iBAAiB,CAAC,UAAO,KAAkB;;gCAAK,sBAAA,cACjD,KAAK,IACR,KAAK,EAAE,gBAAQ,CAAC,KAAK,IACrB,EAAA;;6BAAA,CAAC,CAAC;oBACN,CAAC,CAAC,CAAC;oBAEH,mBAAa,EAAE,CAAC,gBAAgB,CAAC,KAAK,EAAE,EAAE,iBAAiB,EAAE,KAAK,EAAE,CAAC,CAAC;oBAEtE,IAAI,CAAC,gBAAgB,EAAE;wBACrB,gBAAgB,GAAG,IAAI,CAAC;wBACxB,YAAY,CAAC,KAAK,CAAC,CAAC;qBACrB;;;iBACF,CAAC,CAAC;SACJ;aAAM,IAAI,gBAAgB,EAAE;YAC3B,+FAA+F;YAC/F,aAAM,CAAC,IAAI,CAAC,gGAAgG,CAAC,CAAC;YAC9G,mBAAmB,CAAC,KAAK,CAAC,CAAC;SAC5B;aAAM,IAAI,CAAC,iBAAiB,EAAE;YAC7B,4CAA4C;YAC5C,kFAAkF;YAClF,sDAAsD;YACtD,mFAAmF;YACnF,qFAAqF;YACrF,sGAAsG;YACtG,2EAA2E;YAC3E,+EAA+E;YAC/E,oFAAoF;YACpF,mCAAmC;YACnC,6IAA6I;YAC7I,6MAA6M;YAC7M,iHAAiH;YACjH,wGAAwG;YACxG,iBAAiB,GAAG,IAAI,CAAC;YACzB,UAAU,CAAC;gBACT,IAAI,CAAC,gBAAgB,EAAE;oBACrB,+EAA+E;oBAC/E,gBAAgB,GAAG,IAAI,CAAC;oBACxB,YAAY,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;iBACjC;qBAAM;oBACL,+FAA+F;iBAChG;YACH,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,sIAAsI;SACpJ;IACH,CAAC,CAAC;AACJ,CAAC;AA/DD,4CA+DC","sourcesContent":["import { logger } from '@sentry/core';\nimport { getHubFromCarrier, Scope } from '@sentry/hub';\nimport { SentryEvent, Severity } from '@sentry/types';\nimport { forget } from '@sentry/utils/async';\nimport { serialize } from '@sentry/utils/object';\nimport * as cookie from 'cookie';\nimport * as domain from 'domain';\nimport * as http from 'http';\nimport * as os from 'os';\nimport * as url from 'url';\nimport { NodeClient } from './client';\nimport { getCurrentHub } from './hub';\n\nconst DEFAULT_SHUTDOWN_TIMEOUT = 2000;\n\n/** JSDoc */\nfunction extractRequestData(req: { [key: string]: any }): { [key: string]: string } {\n  // headers:\n  //   node, express: req.headers\n  //   koa: req.header\n  const headers = (req.headers || req.header || {}) as {\n    host?: string;\n    cookie?: string;\n  };\n  // method:\n  //   node, express, koa: req.method\n  const method = req.method;\n  // host:\n  //   express: req.hostname in > 4 and req.host in < 4\n  //   koa: req.host\n  //   node: req.headers.host\n  const host = req.hostname || req.host || headers.host || '<no host>';\n  // protocol:\n  //   node: <n/a>\n  //   express, koa: req.protocol\n  const protocol =\n    req.protocol === 'https' || req.secure || ((req.socket || {}) as { encrypted?: boolean }).encrypted\n      ? 'https'\n      : 'http';\n  // url (including path and query string):\n  //   node, express: req.originalUrl\n  //   koa: req.url\n  const originalUrl = (req.originalUrl || req.url) as string;\n  // absolute url\n  const absoluteUrl = `${protocol}://${host}${originalUrl}`;\n  // query string:\n  //   node: req.url (raw)\n  //   express, koa: req.query\n  const query = req.query || url.parse(originalUrl || '', true).query;\n  // cookies:\n  //   node, express, koa: req.headers.cookie\n  const cookies = cookie.parse(headers.cookie || '');\n  // body data:\n  //   node, express, koa: req.body\n  let data = req.body;\n  if (method === 'GET' || method === 'HEAD') {\n    if (typeof data === 'undefined') {\n      data = '<unavailable>';\n    }\n  }\n  if (data && typeof data !== 'string' && {}.toString.call(data) !== '[object String]') {\n    // Make sure the request body is a string\n    data = serialize(data);\n  }\n\n  // request interface\n  const request: {\n    [key: string]: any;\n  } = {\n    cookies,\n    data,\n    headers,\n    method,\n    query_string: query,\n    url: absoluteUrl,\n  };\n\n  return request;\n}\n\n/** JSDoc */\nfunction extractUserData(req: { [key: string]: any }): { [key: string]: string } {\n  const user: { [key: string]: string } = {};\n\n  ['id', 'username', 'email'].forEach(key => {\n    if ({}.hasOwnProperty.call(req.user, key)) {\n      user[key] = (req.user as { [key: string]: string })[key];\n    }\n  });\n\n  // client ip:\n  //   node: req.connection.remoteAddress\n  //   express, koa: req.ip\n  const ip =\n    req.ip ||\n    (req.connection &&\n      (req.connection as {\n        remoteAddress?: string;\n      }).remoteAddress);\n\n  if (ip) {\n    user.ip_address = ip as string;\n  }\n\n  return user;\n}\n\n/** JSDoc */\nfunction parseRequest(\n  event: SentryEvent,\n  req: {\n    [key: string]: any;\n  },\n): SentryEvent {\n  const preparedEvent = {\n    ...event,\n    extra: {\n      ...event.extra,\n      node: global.process.version,\n    },\n    request: {\n      ...event.request,\n      ...extractRequestData(req),\n    },\n    server_name: global.process.env.SENTRY_NAME || os.hostname(),\n  };\n\n  if (req.user) {\n    preparedEvent.user = {\n      ...event.user,\n      ...extractUserData(req),\n    };\n  }\n\n  return preparedEvent;\n}\n\n/** JSDoc */\nexport function requestHandler(): (req: http.IncomingMessage, res: http.ServerResponse, next: () => void) => void {\n  return function sentryRequestMiddleware(\n    req: http.IncomingMessage,\n    _res: http.ServerResponse,\n    next: () => void,\n  ): void {\n    const local = domain.create();\n    const hub = getHubFromCarrier(req);\n    hub.bindClient(getCurrentHub().getClient());\n    hub.configureScope((scope: Scope) => {\n      scope.addEventProcessor(async (event: SentryEvent) => parseRequest(event, req));\n    });\n    local.on('error', next);\n    local.run(next);\n  };\n}\n\n/** JSDoc */\ninterface MiddlewareError extends Error {\n  status?: number | string;\n  statusCode?: number | string;\n  status_code?: number | string;\n  output?: {\n    statusCode?: number | string;\n  };\n}\n\n/** JSDoc */\nfunction getStatusCodeFromResponse(error: MiddlewareError): number {\n  const statusCode = error.status || error.statusCode || error.status_code || (error.output && error.output.statusCode);\n\n  return statusCode ? parseInt(statusCode as string, 10) : 500;\n}\n\n/** JSDoc */\nexport function errorHandler(): (\n  error: MiddlewareError,\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  next: (error: MiddlewareError) => void,\n) => void {\n  return function sentryErrorMiddleware(\n    error: MiddlewareError,\n    req: http.IncomingMessage,\n    _res: http.ServerResponse,\n    next: (error: MiddlewareError) => void,\n  ): void {\n    const status = getStatusCodeFromResponse(error);\n    if (status < 500) {\n      next(error);\n      return;\n    }\n    getHubFromCarrier(req).captureException(error, { originalException: error });\n    next(error);\n  };\n}\n\n/** JSDoc */\nexport function defaultOnFatalError(error: Error): void {\n  console.error(error && error.stack ? error.stack : error);\n  const options = (getCurrentHub().getClient() as NodeClient).getOptions();\n  const timeout =\n    (options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout) ||\n    DEFAULT_SHUTDOWN_TIMEOUT;\n  forget(\n    (getCurrentHub().getClient() as NodeClient).close(timeout).then((result: boolean) => {\n      if (!result) {\n        logger.warn('We reached the timeout for emptying the request buffer, still exiting now!');\n      }\n      global.process.exit(1);\n    }),\n  );\n}\n\n/** JSDoc */\nexport function makeErrorHandler(\n  onFatalError: (firstError: Error, secondError?: Error) => void = defaultOnFatalError,\n): (error: Error) => void {\n  const timeout = 2000;\n  let caughtFirstError: boolean = false;\n  let caughtSecondError: boolean = false;\n  let calledFatalError: boolean = false;\n  let firstError: Error;\n\n  return (error: Error): void => {\n    if (!caughtFirstError) {\n      // this is the first uncaught error and the ultimate reason for shutting down\n      // we want to do absolutely everything possible to ensure it gets captured\n      // also we want to make sure we don't go recursion crazy if more errors happen after this one\n      firstError = error;\n      caughtFirstError = true;\n\n      getCurrentHub().withScope(async () => {\n        getCurrentHub().configureScope((scope: Scope) => {\n          scope.addEventProcessor(async (event: SentryEvent) => ({\n            ...event,\n            level: Severity.Fatal,\n          }));\n        });\n\n        getCurrentHub().captureException(error, { originalException: error });\n\n        if (!calledFatalError) {\n          calledFatalError = true;\n          onFatalError(error);\n        }\n      });\n    } else if (calledFatalError) {\n      // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down\n      logger.warn('uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown');\n      defaultOnFatalError(error);\n    } else if (!caughtSecondError) {\n      // two cases for how we can hit this branch:\n      //   - capturing of first error blew up and we just caught the exception from that\n      //     - quit trying to capture, proceed with shutdown\n      //   - a second independent error happened while waiting for first error to capture\n      //     - want to avoid causing premature shutdown before first error capture finishes\n      // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff\n      // so let's instead just delay a bit before we proceed with our action here\n      // in case 1, we just wait a bit unnecessarily but ultimately do the same thing\n      // in case 2, the delay hopefully made us wait long enough for the capture to finish\n      // two potential nonideal outcomes:\n      //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError\n      //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error\n      // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)\n      //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish\n      caughtSecondError = true;\n      setTimeout(() => {\n        if (!calledFatalError) {\n          // it was probably case 1, let's treat err as the sendErr and call onFatalError\n          calledFatalError = true;\n          onFatalError(firstError, error);\n        } else {\n          // it was probably case 2, our first error finished capturing while we waited, cool, do nothing\n        }\n      }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n    }\n  };\n}\n"]}